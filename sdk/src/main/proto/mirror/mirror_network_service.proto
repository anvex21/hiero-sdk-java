/*-
 * ‌
 * Hedera Mirror Node
 * ​
 * Copyright (C) 2019-2022 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

syntax = "proto3";

package com.hedera.mirror.api.proto;

option java_multiple_files = true; // Required for the reactor-grpc generator to work correctly
option java_package = "com.hedera.hashgraph.sdk.proto.mirror";

import "basic_types.proto";
import "timestamp.proto";
import "transaction.proto";

/**
 * Determines whether the fee estimation depends on network state (e.g., whether an account exists or requires
 * creation during a transfer).
 */
enum EstimateMode {
    /*
     * Estimate based on intrinsic properties plus the latest known state (e.g., check if accounts
     * exist, load token associations). This is the default if no mode is specified.
     */
    STATE = 0;

    /*
     * Estimate based solely on the transaction's inherent properties (e.g., size, signatures, keys). Ignores
     * state-dependent factors.
     */
    INTRINSIC = 1;
}

/**
 * Request object for users, SDKs, and tools to query expected fees without
 * submitting transactions to the network.
 */
message FeeEstimateQuery {
    /**
     * The mode of fee estimation. Defaults to `STATE` if omitted.
     */
    EstimateMode mode = 1;

    /**
     * The raw HAPI transaction that should be estimated.
     */
    .proto.Transaction transaction = 2;
}

/**
 * The extra fee charged for the transaction.
 */
message FeeExtra {
    /**
     * The charged count of items as calculated by `max(0, count - included)`.
     */
    uint32 charged = 1;

    /**
     * The actual count of items received.
     */
    uint32 count = 2;

    /**
     * The fee price per unit in tinycents.
     */
    uint64 fee_per_unit = 3;

    /**
     * The count of this "extra" that is included for free.
     */
    uint32 included = 4;

    /**
     * The unique name of this extra fee as defined in the fee schedule.
     */
    string name = 5;

    /**
     * The subtotal in tinycents for this extra fee. Calculated by multiplying the
     * charged count by the fee_per_unit.
     */
    uint64 subtotal = 6;
}

/**
 * The fee estimate for a component. Includes the base fee and any extras.
 */
message FeeEstimate {
    /**
     * The base fee price, in tinycents.
     */
    uint64 base = 1;

    /**
     * The extra fees that apply for this fee component.
     */
    repeated FeeExtra extras = 2;
}

/**
 * The network fee component which covers the cost of gossip, consensus,
 * signature verifications, fee payment, and storage.
 */
message NetworkFee {
    /**
     * Multiplied by the node fee to determine the total network fee.
     */
    uint32 multiplier = 1;

    /**
     * The subtotal in tinycents for the network fee component which is calculated by
     * multiplying the node subtotal by the network multiplier.
     */
    uint64 subtotal = 2;
}

/**
 * The response containing the estimated transaction fees.
 */
message FeeEstimateResponse {
    /**
     * The mode that was used to calculate the fees.
     */
    EstimateMode mode = 1;

    /**
     * The network fee component which covers the cost of gossip, consensus,
     * signature verifications, fee payment, and storage.
     */
    NetworkFee network = 2;

    /**
     * The node fee component which is to be paid to the node that submitted the
     * transaction to the network. This fee exists to compensate the node for the
     * work it performed to pre-check the transaction before submitting it, and
     * incentivizes the node to accept new transactions from users.
     */
    FeeEstimate node = 3;

    /**
     * An array of strings for any caveats (e.g., ["Fallback to worst-case due to missing state"]).
     */
    repeated string notes = 4;

    /**
     * The service fee component which covers execution costs, state saved in the
     * Merkle tree, and additional costs to the blockchain storage.
     */
    FeeEstimate service = 5;

    /**
     * The sum of the network, node, and service subtotals in tinycents.
     */
    uint64 total = 6;
}

/**
 * Request object to query an address book for its list of nodes
 */
message AddressBookQuery {
    /**
     * The ID of the address book file on the network. Can be either 0.0.101 or 0.0.102.
     */
    .proto.FileID file_id = 1;

    /**
     * The maximum number of node addresses to receive before stopping. If not set or set to zero it will return all node addresses in the database.
     */
    int32 limit = 2;
}

/**
 * Provides cross network APIs like address book queries
 */
service NetworkService {
    /*
     * Query for an address book and return its nodes. The nodes are returned in ascending order by node ID. The
     * response is not guaranteed to be a byte-for-byte equivalent to the NodeAddress in the Hedera file on
     * the network since it is reconstructed from a normalized database table.
     */
    rpc getNodes (AddressBookQuery) returns (stream .proto.NodeAddress);
    /**
     * Query to estimate the fees when submitting a transaction to the network.
     */
    rpc getFeeEstimate (FeeEstimateQuery) returns (FeeEstimateResponse);
}

